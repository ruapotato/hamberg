shader_type spatial;

// Terrain Material - Per-Biome Colors
// Uses dynamic biome texture that follows the player for perfect alignment with minimap
// The texture is generated by GDScript using FastNoiseLite and updated as player moves

uniform int world_seed = 42;
uniform bool debug_biome_colors = false;  // Set to true to show flat biome colors (no shading)

// Dynamic biome texture system - follows the player
uniform sampler2D biome_texture : hint_default_black, filter_linear, repeat_disable;
uniform vec2 biome_texture_center = vec2(0.0, 0.0);  // World position of texture center
uniform float biome_texture_size = 512.0;  // World units covered by the texture

// Biome grass colors (flat/low slope terrain) - Fantasy bright colors, high saturation
const vec3 VALLEY_GRASS = vec3(0.25, 0.55, 0.95);       // BRIGHT BLUE (serene meadows)
const vec3 DARK_FOREST_GRASS = vec3(0.05, 0.25, 0.15); // DARK TEAL-GREEN (bioluminescent dark forest)
const vec3 SWAMP_GRASS = vec3(0.6, 0.75, 0.3);          // YELLOW-GREEN (murky swamp)
const vec3 MOUNTAIN_GRASS = vec3(0.95, 0.97, 1.0);      // WHITE (snow/ice)
const vec3 DESERT_GRASS = vec3(0.95, 0.85, 0.35);       // BRIGHT YELLOW (sandy desert)
const vec3 WIZARDLAND_GRASS = vec3(0.9, 0.3, 1.0);      // BRIGHT MAGENTA (magical)
const vec3 HELL_GRASS = vec3(0.9, 0.2, 0.1);            // BRIGHT RED (hellfire)

// Biome rock colors (steep/high slope terrain) - Darker for contrast, richer colors
const vec3 VALLEY_ROCK = vec3(0.4, 0.42, 0.45);         // Gray stone
const vec3 DARK_FOREST_ROCK = vec3(0.15, 0.2, 0.18);   // Dark mossy stone
const vec3 SWAMP_ROCK = vec3(0.25, 0.22, 0.18);         // Dark muddy stone
const vec3 MOUNTAIN_ROCK = vec3(0.6, 0.62, 0.68);       // Light gray rock
const vec3 DESERT_ROCK = vec3(0.7, 0.58, 0.4);          // Sandy stone
const vec3 WIZARDLAND_ROCK = vec3(0.55, 0.35, 0.65);    // Purple crystal
const vec3 HELL_ROCK = vec3(0.3, 0.12, 0.08);           // Dark obsidian

// Biome difficulty zones (match BiomeGenerator constants)
const float SAFE_ZONE_RADIUS = 5000.0;
const float MID_ZONE_RADIUS = 10000.0;
const float DANGER_ZONE_RADIUS = 15000.0;
const float EXTREME_ZONE_RADIUS = 20000.0;

varying vec3 world_pos;
varying vec3 world_normal;

// ============================================================================
// NOISE FUNCTIONS - Simplex noise to match FastNoiseLite (Godot's built-in)
// ============================================================================

// Permutation and gradient functions for Simplex noise
vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec2 mod289_2(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec3 permute(vec3 x) { return mod289(((x * 34.0) + 1.0) * x); }

// 2D Simplex noise - matches FastNoiseLite TYPE_SIMPLEX_SMOOTH behavior
float simplex2d(vec2 v) {
	const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
	                    0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
	                    -0.577350269189626, // -1.0 + 2.0 * C.x
	                    0.024390243902439); // 1.0 / 41.0

	// First corner
	vec2 i  = floor(v + dot(v, C.yy));
	vec2 x0 = v - i + dot(i, C.xx);

	// Other corners
	vec2 i1;
	i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
	vec4 x12 = x0.xyxy + C.xxzz;
	x12.xy -= i1;

	// Permutations
	i = mod289_2(i);
	vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));

	vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);
	m = m * m;
	m = m * m;

	// Gradients: 41 points uniformly over a line, mapped onto a diamond
	vec3 x = 2.0 * fract(p * C.www) - 1.0;
	vec3 h = abs(x) - 0.5;
	vec3 ox = floor(x + 0.5);
	vec3 a0 = x - ox;

	// Normalize gradients implicitly by scaling m
	m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);

	// Compute final noise value at P
	vec3 g;
	g.x = a0.x * x0.x + h.x * x0.y;
	g.yz = a0.yz * x12.xz + h.yz * x12.yw;
	return 130.0 * dot(m, g);  // Scale to approximately -1 to 1
}

// Fractal Brownian Motion using Simplex noise - matches FastNoiseLite FBM
float fbm(vec2 p, int seed, float frequency, int octaves, float lacunarity, float gain) {
	float value = 0.0;
	float amplitude = 1.0;
	float total_amplitude = 0.0;

	// Offset position by seed for variation (each noise instance has different seed)
	vec2 pos = p * frequency + vec2(float(seed) * 12.9898, float(seed) * 78.233);

	for (int i = 0; i < 8; i++) {
		if (i >= octaves) break;

		value += simplex2d(pos) * amplitude;
		total_amplitude += amplitude;

		pos *= lacunarity;
		amplitude *= gain;
	}

	return value / total_amplitude;
}

// ============================================================================
// BIOME SELECTION - Replicates BiomeGenerator._get_biome_at_position()
// ============================================================================

int get_biome_index(vec2 xz_pos) {
	// Calculate distance from origin
	float distance = length(xz_pos);

	// Domain warping for organic distortion (Valheim-style)
	float warp_strength = 800.0;
	float warp_x = fbm(xz_pos, world_seed + 200, 0.0005, 2, 2.0, 0.5) * warp_strength;
	float warp_z = fbm(xz_pos, world_seed + 201, 0.0005, 2, 2.0, 0.5) * warp_strength;

	vec2 warped_pos = xz_pos + vec2(warp_x, warp_z);

	// Sample biome noise at warped position
	float biome_value = fbm(warped_pos, world_seed + 100, 0.0008, 3, 2.0, 0.5);

	// Sample scale noise to vary biome patch sizes
	float scale_value = fbm(xz_pos, world_seed + 300, 0.001, 2, 2.0, 0.5);

	// Combine biome noise with scale for more variation
	float combined_value = biome_value + (scale_value * 0.3);

	// Normalize to 0-1 range
	float normalized = (combined_value + 1.0) * 0.5;

	// Determine difficulty tier based on distance
	int difficulty_tier = 0;
	if (distance < SAFE_ZONE_RADIUS) {
		difficulty_tier = 0;  // Safe biomes only (valley, forest)
	} else if (distance < MID_ZONE_RADIUS) {
		difficulty_tier = 1;  // Mid-game biomes
	} else if (distance < DANGER_ZONE_RADIUS) {
		difficulty_tier = 2;  // Dangerous biomes
	} else {
		difficulty_tier = 3;  // Mostly hell
	}

	// Select biome based on noise value and difficulty tier
	// Returns: 0=valley, 1=forest, 2=swamp, 3=mountain, 4=desert, 5=wizardland, 6=hell
	// EXACTLY matches BiomeGenerator._get_biome_at_position()
	if (difficulty_tier == 0) {  // Safe zone - valley and forest only
		if (normalized < 0.5) {
			return 0;  // valley
		} else {
			return 1;  // forest
		}
	} else if (difficulty_tier == 1) {  // Mid zone - more variety with swamp and desert
		if (normalized < 0.25) {
			return 0;  // valley (some safe areas still exist)
		} else if (normalized < 0.5) {
			return 1;  // forest
		} else if (normalized < 0.75) {
			return 2;  // swamp
		} else {
			return 4;  // desert
		}
	} else if (difficulty_tier == 2) {  // Danger zone - mountains and wizardland appear
		if (normalized < 0.15) {
			return 1;  // forest (occasional safe pockets)
		} else if (normalized < 0.3) {
			return 2;  // swamp
		} else if (normalized < 0.5) {
			return 4;  // desert
		} else if (normalized < 0.7) {
			return 3;  // mountain
		} else if (normalized < 0.9) {
			return 5;  // wizardland (FIXED: was 0.85, should be 0.9)
		} else {
			return 6;  // hell (hell starts appearing)
		}
	} else if (difficulty_tier == 3) {  // Extreme zone - heavy hell presence
		if (normalized < 0.15) {
			return 4;  // desert
		} else if (normalized < 0.3) {
			return 3;  // mountain
		} else if (normalized < 0.45) {
			return 5;  // wizardland
		} else {
			return 6;  // hell (hell is dominant)
		}
	} else {  // Beyond extreme - mostly pure hell
		if (normalized < 0.15) {
			return 3;  // mountain
		} else if (normalized < 0.25) {
			return 5;  // wizardland
		} else {
			return 6;  // hell (hell overwhelms)
		}
	}

	return 0;  // Fallback to valley
}

vec3 get_biome_grass_color(int biome_index) {
	if (biome_index == 0) return VALLEY_GRASS;
	else if (biome_index == 1) return DARK_FOREST_GRASS;
	else if (biome_index == 2) return SWAMP_GRASS;
	else if (biome_index == 3) return MOUNTAIN_GRASS;
	else if (biome_index == 4) return DESERT_GRASS;
	else if (biome_index == 5) return WIZARDLAND_GRASS;
	else if (biome_index == 6) return HELL_GRASS;
	return VALLEY_GRASS;  // Fallback
}

vec3 get_biome_rock_color(int biome_index) {
	if (biome_index == 0) return VALLEY_ROCK;
	else if (biome_index == 1) return DARK_FOREST_ROCK;
	else if (biome_index == 2) return SWAMP_ROCK;
	else if (biome_index == 3) return MOUNTAIN_ROCK;
	else if (biome_index == 4) return DESERT_ROCK;
	else if (biome_index == 5) return WIZARDLAND_ROCK;
	else if (biome_index == 6) return HELL_ROCK;
	return VALLEY_ROCK;  // Fallback
}

// ============================================================================
// NOISE FUNCTIONS
// ============================================================================

// Sin-based random function - returns value between 0 and 1
float simple_rand(vec2 p) {
	return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
}

// Value noise - interpolate between random values at grid corners
float value_noise_simple(vec2 p) {
	vec2 i = floor(p);
	vec2 f = fract(p);

	// Get random values at 4 corners
	float a = simple_rand(i);
	float b = simple_rand(i + vec2(1.0, 0.0));
	float c = simple_rand(i + vec2(0.0, 1.0));
	float d = simple_rand(i + vec2(1.0, 1.0));

	// Smooth interpolation curve
	vec2 u = f * f * (3.0 - 2.0 * f);

	// Bilinear interpolation
	return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
}

// Multi-octave noise
float multi_octave_noise(vec2 p) {
	float result = 0.0;
	float amp = 0.5;
	float freq = 1.0;

	result += value_noise_simple(p * freq * 2.0) * amp;
	amp *= 0.5; freq *= 2.0;

	result += value_noise_simple(p * freq * 2.0) * amp;
	amp *= 0.5; freq *= 2.0;

	result += value_noise_simple(p * freq * 2.0) * amp;
	amp *= 0.5; freq *= 2.0;

	result += value_noise_simple(p * freq * 2.0) * amp;

	return result;
}

// ============================================================================
// VERTEX AND FRAGMENT SHADERS
// ============================================================================

void vertex() {
	world_pos = (MODEL_MATRIX * vec4(VERTEX, 1.0)).xyz;
	// Transform normal to world space using inverse transpose for correct orientation
	world_normal = normalize(mat3(MODEL_MATRIX) * NORMAL);
}

// Biome blend info structure
struct BiomeBlendInfo {
	int primary_biome;
	int secondary_biome;
	float blend_weight;
	bool valid;
};

// Sample biome blend info from dynamic texture (follows player, generated by GDScript)
BiomeBlendInfo sample_biome_blend_from_texture(vec2 xz_pos) {
	BiomeBlendInfo info;
	info.valid = false;
	info.primary_biome = 0;
	info.secondary_biome = 0;
	info.blend_weight = 0.0;

	// Calculate UV coordinates relative to texture center
	vec2 offset = xz_pos - biome_texture_center;
	vec2 uv = (offset / biome_texture_size) + 0.5;  // 0-1 range, centered

	// Clamp to texture bounds - outside the texture, fall back to procedural
	if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
		return info;  // Signal to use fallback
	}

	// Sample texture - R=primary biome, G=secondary biome, B=blend weight
	vec3 tex_data = texture(biome_texture, uv).rgb;
	info.primary_biome = int(tex_data.r * 7.0 + 0.5);
	info.secondary_biome = int(tex_data.g * 7.0 + 0.5);
	info.blend_weight = tex_data.b;
	info.valid = true;

	return info;
}

// Legacy function for compatibility
int sample_biome_from_texture(vec2 xz_pos) {
	BiomeBlendInfo info = sample_biome_blend_from_texture(xz_pos);
	if (!info.valid) return -1;
	return info.primary_biome;
}

void fragment() {
	vec2 xz_pos = world_pos.xz;

	// Try to get biome blend info from dynamic texture (perfect alignment with minimap)
	BiomeBlendInfo blend_info = sample_biome_blend_from_texture(xz_pos);

	vec3 grass_color;
	vec3 rock_color;

	if (blend_info.valid) {
		// Get colors for both biomes
		vec3 primary_grass = get_biome_grass_color(blend_info.primary_biome);
		vec3 primary_rock = get_biome_rock_color(blend_info.primary_biome);

		// If blending with a secondary biome
		if (blend_info.blend_weight > 0.001) {
			vec3 secondary_grass = get_biome_grass_color(blend_info.secondary_biome);
			vec3 secondary_rock = get_biome_rock_color(blend_info.secondary_biome);

			// Blend between primary and secondary based on weight
			grass_color = mix(primary_grass, secondary_grass, blend_info.blend_weight);
			rock_color = mix(primary_rock, secondary_rock, blend_info.blend_weight);
		} else {
			grass_color = primary_grass;
			rock_color = primary_rock;
		}
	} else {
		// Fall back to procedural if outside texture bounds
		int biome_idx = get_biome_index(xz_pos);
		grass_color = get_biome_grass_color(biome_idx);
		rock_color = get_biome_rock_color(biome_idx);
	}

	// Calculate slope based on how vertical the surface is (in world space)
	// world_normal.y is 1.0 for perfectly flat ground (pointing straight up)
	// world_normal.y is 0.0 for vertical walls (pointing sideways)
	// We want: flat (world_normal.y near 1.0) = grass, steep (world_normal.y near 0.0) = rock
	float flatness = world_normal.y;  // 1.0 = flat, 0.0 = vertical

	// Blend between grass and rock based on slope
	// At 45 degrees (max walkable), normal.y = cos(45°) ≈ 0.707
	// flatness > 0.85 = flat, mostly grass
	// flatness < 0.70 = steep/walkable limit, mostly rock
	// Smooth transition between 0.70 and 0.85 (shows more rock on moderate slopes)
	float rock_blend = 1.0 - smoothstep(0.70, 0.85, flatness);
	vec3 base_color = mix(grass_color, rock_color, rock_blend);

	// Apply our custom noise function using full 3D position to avoid stripes on vertical surfaces
	// Mix XZ and XY/YZ patterns based on surface normal
	float noise_xz = multi_octave_noise(world_pos.xz * 0.3);
	float noise_xy = multi_octave_noise(world_pos.xy * 0.3);
	float noise_yz = multi_octave_noise(world_pos.yz * 0.3);

	// Blend noise based on surface orientation
	// Horizontal surfaces use XZ, vertical surfaces use XY/YZ
	vec3 blend_weights = abs(world_normal);
	blend_weights = blend_weights / (blend_weights.x + blend_weights.y + blend_weights.z);

	float noise_val = noise_xz * blend_weights.y +  // Horizontal surfaces
	                  noise_xy * blend_weights.z +  // North/South facing
	                  noise_yz * blend_weights.x;   // East/West facing

	// Convert to -1 to 1 range for color variation
	float combined = (noise_val - 0.5) * 2.0;

	// Apply variation to base color
	vec3 color = base_color * (1.0 + combined * 0.4);

	// Simple directional lighting
	vec3 light_dir = normalize(vec3(0.5, 1.0, 0.3));
	float ndotl = max(dot(world_normal, light_dir), 0.0);
	float ambient = 0.6;
	float lighting = ambient + (1.0 - ambient) * ndotl;

	// Debug mode: directly show the grass color from texture (for troubleshooting)
	if (debug_biome_colors) {
		// Show grass color directly - reveals if biome texture is working
		ALBEDO = grass_color;
		ROUGHNESS = 0.9;
		METALLIC = 0.0;
	} else {
		ALBEDO = color * lighting;
		// Rocky areas are slightly rougher
		ROUGHNESS = mix(0.85, 0.95, rock_blend);
		METALLIC = 0.0;
	}
}
