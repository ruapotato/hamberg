shader_type spatial;

// Terrain Material - Per-Biome Colors
// Uses dynamic biome texture that follows the player for perfect alignment with minimap
// The texture is generated by GDScript using FastNoiseLite and updated as player moves

uniform int world_seed = 42;
uniform bool debug_biome_colors = false;  // Set to true to show flat biome colors (no shading)
uniform float time = 0.0;  // Time for grass animation (set from GDScript)
uniform bool enable_grass_detail = true;  // Enable shader-based grass detail
uniform vec3 camera_position = vec3(0.0, 0.0, 0.0);  // Camera position for LOD

// Snow coverage (set by WeatherManager)
uniform float snow_coverage : hint_range(0.0, 1.0) = 0.0;  // 0.0 = no snow, 1.0 = full snow
uniform float snow_height : hint_range(0.0, 0.5) = 0.15;  // Max height of snow layer in world units

// Footprint system
uniform sampler2D footprint_texture : hint_default_white, filter_linear, repeat_disable;
uniform vec2 footprint_texture_center = vec2(0.0, 0.0);  // World position of footprint texture center
uniform float footprint_texture_size = 64.0;  // World units covered by footprint texture

// LOD distance thresholds
const float LOD_NEAR_DISTANCE = 40.0;    // Full detail
const float LOD_MID_DISTANCE = 80.0;     // Reduced detail
const float LOD_FAR_DISTANCE = 150.0;    // Minimal detail (flat colors)

// Dynamic biome texture system - follows the player
uniform sampler2D biome_texture : hint_default_black, filter_linear, repeat_disable;
uniform vec2 biome_texture_center = vec2(0.0, 0.0);  // World position of texture center
uniform float biome_texture_size = 512.0;  // World units covered by the texture

// Biome grass colors (flat/low slope terrain) - Fantasy bright colors, high saturation
const vec3 VALLEY_GRASS = vec3(0.25, 0.55, 0.95);       // BRIGHT BLUE (serene meadows)
const vec3 DARK_FOREST_GRASS = vec3(0.05, 0.25, 0.15); // DARK TEAL-GREEN (bioluminescent dark forest)
const vec3 SWAMP_GRASS = vec3(0.6, 0.75, 0.3);          // YELLOW-GREEN (murky swamp)
const vec3 MOUNTAIN_GRASS = vec3(0.95, 0.97, 1.0);      // WHITE (snow/ice)
const vec3 DESERT_GRASS = vec3(0.95, 0.85, 0.35);       // BRIGHT YELLOW (sandy desert)
const vec3 WIZARDLAND_GRASS = vec3(0.9, 0.3, 1.0);      // BRIGHT MAGENTA (magical)
const vec3 HELL_GRASS = vec3(0.9, 0.2, 0.1);            // BRIGHT RED (hellfire)

// Biome rock colors (steep/high slope terrain) - Darker for contrast, richer colors
const vec3 VALLEY_ROCK = vec3(0.4, 0.42, 0.45);         // Gray stone
const vec3 DARK_FOREST_ROCK = vec3(0.15, 0.2, 0.18);   // Dark mossy stone
const vec3 SWAMP_ROCK = vec3(0.25, 0.22, 0.18);         // Dark muddy stone
const vec3 MOUNTAIN_ROCK = vec3(0.6, 0.62, 0.68);       // Light gray rock
const vec3 DESERT_ROCK = vec3(0.7, 0.58, 0.4);          // Sandy stone
const vec3 WIZARDLAND_ROCK = vec3(0.55, 0.35, 0.65);    // Purple crystal
const vec3 HELL_ROCK = vec3(0.3, 0.12, 0.08);           // Dark obsidian

// Biome difficulty zones (match BiomeGenerator constants)
const float SPAWN_VALLEY_RADIUS = 100.0;  // Always valley near spawn (safe starting area)
const float SAFE_ZONE_RADIUS = 5000.0;
const float MID_ZONE_RADIUS = 10000.0;
const float DANGER_ZONE_RADIUS = 15000.0;
const float EXTREME_ZONE_RADIUS = 20000.0;

varying vec3 world_pos;
varying vec3 world_normal;

// ============================================================================
// NOISE FUNCTIONS - Simplex noise to match FastNoiseLite (Godot's built-in)
// ============================================================================

// Permutation and gradient functions for Simplex noise
vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec2 mod289_2(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec3 permute(vec3 x) { return mod289(((x * 34.0) + 1.0) * x); }

// 2D Simplex noise - matches FastNoiseLite TYPE_SIMPLEX_SMOOTH behavior
float simplex2d(vec2 v) {
	const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
	                    0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
	                    -0.577350269189626, // -1.0 + 2.0 * C.x
	                    0.024390243902439); // 1.0 / 41.0

	// First corner
	vec2 i  = floor(v + dot(v, C.yy));
	vec2 x0 = v - i + dot(i, C.xx);

	// Other corners
	vec2 i1;
	i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
	vec4 x12 = x0.xyxy + C.xxzz;
	x12.xy -= i1;

	// Permutations
	i = mod289_2(i);
	vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));

	vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);
	m = m * m;
	m = m * m;

	// Gradients: 41 points uniformly over a line, mapped onto a diamond
	vec3 x = 2.0 * fract(p * C.www) - 1.0;
	vec3 h = abs(x) - 0.5;
	vec3 ox = floor(x + 0.5);
	vec3 a0 = x - ox;

	// Normalize gradients implicitly by scaling m
	m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);

	// Compute final noise value at P
	vec3 g;
	g.x = a0.x * x0.x + h.x * x0.y;
	g.yz = a0.yz * x12.xz + h.yz * x12.yw;
	return 130.0 * dot(m, g);  // Scale to approximately -1 to 1
}

// Fractal Brownian Motion using Simplex noise - matches FastNoiseLite FBM
// PERFORMANCE: Reduced max iterations from 8 to 4 for better GPU performance
float fbm(vec2 p, int seed, float frequency, int octaves, float lacunarity, float gain) {
	float value = 0.0;
	float amplitude = 1.0;
	float total_amplitude = 0.0;

	// Offset position by seed for variation (each noise instance has different seed)
	vec2 pos = p * frequency + vec2(float(seed) * 12.9898, float(seed) * 78.233);

	// PERFORMANCE: Cap at 4 octaves max for better performance (was 8)
	int max_octaves = min(octaves, 4);

	for (int i = 0; i < 4; i++) {
		if (i >= max_octaves) break;

		value += simplex2d(pos) * amplitude;
		total_amplitude += amplitude;

		pos *= lacunarity;
		amplitude *= gain;
	}

	return value / total_amplitude;
}

// ============================================================================
// BIOME SELECTION - Replicates BiomeGenerator._get_biome_at_position()
// ============================================================================

int get_biome_index(vec2 xz_pos) {
	// Calculate distance from origin
	float distance = length(xz_pos);

	// Force valley biome near spawn point (safe starting area)
	if (distance < SPAWN_VALLEY_RADIUS) {
		return 0;  // valley
	}

	// Domain warping for organic distortion (Valheim-style)
	float warp_strength = 800.0;
	float warp_x = fbm(xz_pos, world_seed + 200, 0.0005, 2, 2.0, 0.5) * warp_strength;
	float warp_z = fbm(xz_pos, world_seed + 201, 0.0005, 2, 2.0, 0.5) * warp_strength;

	vec2 warped_pos = xz_pos + vec2(warp_x, warp_z);

	// Sample biome noise at warped position
	float biome_value = fbm(warped_pos, world_seed + 100, 0.0008, 3, 2.0, 0.5);

	// Sample scale noise to vary biome patch sizes
	float scale_value = fbm(xz_pos, world_seed + 300, 0.001, 2, 2.0, 0.5);

	// Combine biome noise with scale for more variation
	float combined_value = biome_value + (scale_value * 0.3);

	// Normalize to 0-1 range
	float normalized = (combined_value + 1.0) * 0.5;

	// Determine difficulty tier based on distance
	int difficulty_tier = 0;
	if (distance < SAFE_ZONE_RADIUS) {
		difficulty_tier = 0;  // Safe biomes only (valley, forest)
	} else if (distance < MID_ZONE_RADIUS) {
		difficulty_tier = 1;  // Mid-game biomes
	} else if (distance < DANGER_ZONE_RADIUS) {
		difficulty_tier = 2;  // Dangerous biomes
	} else {
		difficulty_tier = 3;  // Mostly hell
	}

	// Select biome based on noise value and difficulty tier
	// Returns: 0=valley, 1=forest, 2=swamp, 3=mountain, 4=desert, 5=wizardland, 6=hell
	// EXACTLY matches BiomeGenerator._get_biome_at_position()
	if (difficulty_tier == 0) {  // Safe zone - valley and forest only
		if (normalized < 0.5) {
			return 0;  // valley
		} else {
			return 1;  // forest
		}
	} else if (difficulty_tier == 1) {  // Mid zone - more variety with swamp and desert
		if (normalized < 0.25) {
			return 0;  // valley (some safe areas still exist)
		} else if (normalized < 0.5) {
			return 1;  // forest
		} else if (normalized < 0.75) {
			return 2;  // swamp
		} else {
			return 4;  // desert
		}
	} else if (difficulty_tier == 2) {  // Danger zone - mountains and wizardland appear
		if (normalized < 0.15) {
			return 1;  // forest (occasional safe pockets)
		} else if (normalized < 0.3) {
			return 2;  // swamp
		} else if (normalized < 0.5) {
			return 4;  // desert
		} else if (normalized < 0.7) {
			return 3;  // mountain
		} else if (normalized < 0.9) {
			return 5;  // wizardland (FIXED: was 0.85, should be 0.9)
		} else {
			return 6;  // hell (hell starts appearing)
		}
	} else if (difficulty_tier == 3) {  // Extreme zone - heavy hell presence
		if (normalized < 0.15) {
			return 4;  // desert
		} else if (normalized < 0.3) {
			return 3;  // mountain
		} else if (normalized < 0.45) {
			return 5;  // wizardland
		} else {
			return 6;  // hell (hell is dominant)
		}
	} else {  // Beyond extreme - mostly pure hell
		if (normalized < 0.15) {
			return 3;  // mountain
		} else if (normalized < 0.25) {
			return 5;  // wizardland
		} else {
			return 6;  // hell (hell overwhelms)
		}
	}

	return 0;  // Fallback to valley
}

vec3 get_biome_grass_color(int biome_index) {
	if (biome_index == 0) return VALLEY_GRASS;
	else if (biome_index == 1) return DARK_FOREST_GRASS;
	else if (biome_index == 2) return SWAMP_GRASS;
	else if (biome_index == 3) return MOUNTAIN_GRASS;
	else if (biome_index == 4) return DESERT_GRASS;
	else if (biome_index == 5) return WIZARDLAND_GRASS;
	else if (biome_index == 6) return HELL_GRASS;
	return VALLEY_GRASS;  // Fallback
}

vec3 get_biome_rock_color(int biome_index) {
	if (biome_index == 0) return VALLEY_ROCK;
	else if (biome_index == 1) return DARK_FOREST_ROCK;
	else if (biome_index == 2) return SWAMP_ROCK;
	else if (biome_index == 3) return MOUNTAIN_ROCK;
	else if (biome_index == 4) return DESERT_ROCK;
	else if (biome_index == 5) return WIZARDLAND_ROCK;
	else if (biome_index == 6) return HELL_ROCK;
	return VALLEY_ROCK;  // Fallback
}

// ============================================================================
// NOISE FUNCTIONS
// ============================================================================

// Sin-based random function - returns value between 0 and 1
float simple_rand(vec2 p) {
	return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
}

// Value noise - interpolate between random values at grid corners
float value_noise_simple(vec2 p) {
	vec2 i = floor(p);
	vec2 f = fract(p);

	// Get random values at 4 corners
	float a = simple_rand(i);
	float b = simple_rand(i + vec2(1.0, 0.0));
	float c = simple_rand(i + vec2(0.0, 1.0));
	float d = simple_rand(i + vec2(1.0, 1.0));

	// Smooth interpolation curve
	vec2 u = f * f * (3.0 - 2.0 * f);

	// Bilinear interpolation
	return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
}

// Multi-octave noise
float multi_octave_noise(vec2 p) {
	float result = 0.0;
	float amp = 0.5;
	float freq = 1.0;

	result += value_noise_simple(p * freq * 2.0) * amp;
	amp *= 0.5; freq *= 2.0;

	result += value_noise_simple(p * freq * 2.0) * amp;
	amp *= 0.5; freq *= 2.0;

	result += value_noise_simple(p * freq * 2.0) * amp;
	amp *= 0.5; freq *= 2.0;

	result += value_noise_simple(p * freq * 2.0) * amp;

	return result;
}

// ============================================================================
// GRASS DETAIL FUNCTIONS - Creates realistic grass-like visual pattern
// ============================================================================

// Hash function for pseudo-random values
vec2 hash22(vec2 p) {
	vec3 p3 = fract(vec3(p.xyx) * vec3(0.1031, 0.1030, 0.0973));
	p3 += dot(p3, p3.yzx + 33.33);
	return fract((p3.xx + p3.yz) * p3.zy);
}

float hash21(vec2 p) {
	return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

// Grass blade shape - creates a thin vertical blade with pointed tip
// Returns intensity (0-1) where 1 is the blade, 0 is between blades
float blade_shape(vec2 uv, float blade_width, float blade_height, float bend) {
	// Blade tapers from base to tip
	float taper = 1.0 - (uv.y / blade_height);
	taper = max(0.0, taper);
	float current_width = blade_width * (0.3 + 0.7 * taper);

	// Blade bends more at the top
	float bend_amount = bend * uv.y * uv.y / (blade_height * blade_height);
	float blade_x = uv.x - bend_amount;

	// Distance from blade center
	float dist = abs(blade_x) / current_width;

	// Soft blade edge
	float blade = 1.0 - smoothstep(0.3, 1.0, dist);

	// Fade at top (pointed tip)
	blade *= smoothstep(blade_height, blade_height * 0.85, uv.y);

	// Only draw within blade height
	blade *= step(0.0, uv.y) * step(uv.y, blade_height);

	return blade;
}

// Single grass clump - multiple blades emanating from a point
// PERFORMANCE: Reduced from 5 blades to 3 blades per clump
float grass_clump(vec2 p, vec2 clump_center, float wind_phase, float clump_size) {
	vec2 local = p - clump_center;

	float total = 0.0;

	// PERFORMANCE: Generate 2-3 blades per clump (was 3-5)
	float blade_count = 2.0 + hash21(clump_center);

	for (float i = 0.0; i < 3.0; i++) {
		if (i >= blade_count) break;

		// Randomize blade properties
		vec2 seed = clump_center + vec2(i * 17.31, i * 23.17);
		vec2 rnd = hash22(seed);

		// Blade offset from clump center
		float angle = (i / blade_count) * 6.28 + rnd.x * 0.5;
		float offset_dist = rnd.y * clump_size * 0.3;
		vec2 blade_base = vec2(cos(angle), sin(angle)) * offset_dist;

		// Blade dimensions
		float blade_height = clump_size * (0.6 + rnd.x * 0.4);
		float blade_width = clump_size * 0.08 * (0.7 + rnd.y * 0.3);

		// Wind bend - varies by blade and time
		float wind_strength = 0.3 + rnd.x * 0.4;
		float wind = sin(wind_phase + rnd.y * 6.28 + local.x * 0.5) * wind_strength;
		wind *= clump_size * 0.5;

		// Transform to blade-local coordinates
		vec2 blade_local = local - blade_base;

		// Create pseudo-3D effect: blade "height" mapped to pattern
		float dist_from_base = length(blade_local);
		float blade_y = dist_from_base;
		float blade_x = blade_local.x * 0.5 + blade_local.y * 0.5;

		float blade = blade_shape(vec2(blade_x, blade_y), blade_width, blade_height, wind);

		// Combine blades
		total = max(total, blade * (0.7 + 0.3 * (1.0 - i / blade_count)));
	}

	return clamp(total, 0.0, 1.0);
}

// Structure to hold grass rendering info
struct GrassInfo {
	float coverage;      // How much grass (0-1)
	float height;        // Relative height on blade (0=base, 1=tip)
	float shadow;        // Shadow between blades
	float wind_bend;     // Current wind bend amount
};

// Main grass pattern function - creates a field of grass clumps
// PERFORMANCE: Reduced from 3x3 grid with 2 clumps to 2x2 grid with 1 clump (was 18 checks, now 4)
GrassInfo get_grass_pattern(vec2 world_xz, float anim_time) {
	GrassInfo info;
	info.coverage = 0.0;
	info.height = 0.0;
	info.shadow = 0.0;
	info.wind_bend = 0.0;

	// Scale for grass (larger = bigger clumps, more spread out)
	float grass_scale = 3.0;  // Increased for efficiency
	vec2 scaled_pos = world_xz / grass_scale;

	// Wind parameters (simplified)
	float wind_phase = anim_time * 1.2 + world_xz.x * 0.02;

	// Grid-based clump placement with jitter
	vec2 grid_cell = floor(scaled_pos);

	float total_grass = 0.0;
	float total_height = 0.0;
	float weight_sum = 0.0;

	// PERFORMANCE: Check only 2x2 nearby cells with 1 clump each (was 3x3 with 2 clumps)
	for (int dx = 0; dx <= 1; dx++) {
		for (int dy = 0; dy <= 1; dy++) {
			vec2 cell = grid_cell + vec2(float(dx), float(dy));
			vec2 rnd = hash22(cell);

			// Skip some cells for variation
			if (rnd.x > 0.8) continue;

			// Clump position with jitter
			vec2 clump_pos = (cell + hash22(cell + 0.5)) * grass_scale;

			// Clump size variation
			float clump_size = grass_scale * (0.7 + rnd.y * 0.5);

			// Distance check for early exit
			float dist = length(world_xz - clump_pos);
			if (dist > clump_size * 1.2) continue;

			// Get grass from this clump
			float grass = grass_clump(world_xz, clump_pos, wind_phase, clump_size);

			if (grass > 0.01) {
				float h = clamp(dist / clump_size, 0.0, 1.0);
				total_height += h * grass;
				weight_sum += grass;
				total_grass = max(total_grass, grass);
			}
		}
	}

	info.coverage = total_grass;
	info.height = weight_sum > 0.0 ? total_height / weight_sum : 0.0;

	// Simplified shadow calculation
	info.shadow = (1.0 - info.height) * 0.2 * info.coverage;

	// Wind bend visualization
	info.wind_bend = sin(wind_phase) * 0.5 + 0.5;

	return info;
}

// Get grass detail for fragment shader
float get_grass_detail(vec2 xz_pos, float flatness, int biome_idx, float anim_time) {
	// Only show grass on flat terrain
	float slope_factor = smoothstep(0.80, 0.95, flatness);
	if (slope_factor < 0.01) return 0.0;

	// Grass intensity varies by biome
	float biome_grass_intensity = 0.0;
	if (biome_idx == 0) biome_grass_intensity = 1.0;       // Valley - lots of grass
	else if (biome_idx == 1) biome_grass_intensity = 0.3;  // Dark forest - some grass
	else if (biome_idx == 2) biome_grass_intensity = 0.5;  // Swamp - muddy grass
	else if (biome_idx == 3) biome_grass_intensity = 0.0;  // Mountain - no grass (snow)
	else if (biome_idx == 4) biome_grass_intensity = 0.0;  // Desert - no grass
	else if (biome_idx == 5) biome_grass_intensity = 0.4;  // Wizardland - magical grass
	else if (biome_idx == 6) biome_grass_intensity = 0.0;  // Hell - no grass

	if (biome_grass_intensity < 0.01) return 0.0;

	// Get detailed grass pattern
	GrassInfo grass = get_grass_pattern(xz_pos, anim_time);

	// Combine factors
	return grass.coverage * slope_factor * biome_grass_intensity;
}

// ============================================================================
// FOREST FLOOR PATTERN - Mushrooms and roots for dark forest biome
// ============================================================================

// Structure for forest floor rendering info
struct ForestFloorInfo {
	float coverage;      // How much pattern visible (0-1)
	float is_mushroom;   // 1.0 = mushroom cap, 0.0 = root/moss
	float is_root;       // 1.0 = root tendril
	float height;        // Height on element (0=base, 1=top)
	float glow;          // Bioluminescent glow amount
};

// Mushroom cap shape - creates round caps with darker gills underneath
float mushroom_cap(vec2 p, vec2 center, float radius) {
	float dist = length(p - center);

	// Soft circular cap
	float cap = 1.0 - smoothstep(radius * 0.6, radius, dist);

	// Darker ring for gills at edge
	float gill_ring = smoothstep(radius * 0.4, radius * 0.7, dist) *
	                  (1.0 - smoothstep(radius * 0.7, radius * 0.9, dist));

	return cap - gill_ring * 0.3;
}

// Root tendril pattern - creates twisting organic lines
float root_tendril(vec2 p, float anim_time) {
	// Multiple overlapping root patterns at different scales
	float root = 0.0;

	// Create twisting tendrils using sine waves
	for (float i = 0.0; i < 4.0; i++) {
		float angle = i * 0.785 + hash21(vec2(i, 0.0)) * 3.14;
		vec2 dir = vec2(cos(angle), sin(angle));

		// Project position onto root direction
		float along = dot(p, dir);
		float perp = dot(p, vec2(-dir.y, dir.x));

		// Wavy root pattern
		float wave = sin(along * 2.0 + i * 2.0 + anim_time * 0.05) * 0.3;
		float root_dist = abs(perp - wave);

		// Thickness varies along length
		float thickness = 0.08 + 0.04 * sin(along * 3.0 + i);

		float tendril = 1.0 - smoothstep(thickness * 0.5, thickness, root_dist);

		// Fade at ends
		tendril *= smoothstep(-2.0, -0.5, along) * smoothstep(2.0, 0.5, along);

		root = max(root, tendril * (0.6 + 0.4 * hash21(vec2(i, 1.0))));
	}

	return root;
}

// Get forest floor pattern for dark forest biome
// PERFORMANCE: Reduced from 3x3 grid with 4 mushrooms to 2x2 grid with 2 mushrooms (was 36 checks, now 8)
ForestFloorInfo get_forest_floor_pattern(vec2 world_xz, float anim_time) {
	ForestFloorInfo info;
	info.coverage = 0.0;
	info.is_mushroom = 0.0;
	info.is_root = 0.0;
	info.height = 0.0;
	info.glow = 0.0;

	float pattern_scale = 2.5;  // Slightly larger for efficiency
	vec2 scaled_pos = world_xz / pattern_scale;

	// Grid for mushroom placement
	vec2 grid_cell = floor(scaled_pos);

	float mushroom_total = 0.0;

	// PERFORMANCE: Check only 2x2 nearby cells with 2 mushrooms each (was 3x3 with 4)
	for (int dx = 0; dx <= 1; dx++) {
		for (int dy = 0; dy <= 1; dy++) {
			vec2 cell = grid_cell + vec2(float(dx), float(dy));

			for (int m = 0; m < 2; m++) {
				vec2 mush_seed = cell + vec2(float(m) * 0.5, float(m) * 0.5);
				vec2 rnd = hash22(mush_seed);

				// Only 25% of potential mushrooms exist
				if (rnd.x > 0.25) continue;

				// Mushroom position with jitter
				vec2 mush_pos = (cell + hash22(mush_seed + 0.5)) * pattern_scale;

				// Mushroom size variation
				float mush_radius = pattern_scale * (0.15 + rnd.y * 0.25);

				// Distance check
				float dist = length(world_xz - mush_pos);
				if (dist > mush_radius * 1.2) continue;

				// Get mushroom cap pattern
				float cap = mushroom_cap(world_xz, mush_pos, mush_radius);

				if (cap > mushroom_total) {
					mushroom_total = cap;
					info.height = 1.0 - clamp(dist / (mush_radius * 0.8), 0.0, 1.0);

					// Glow for bioluminescent effect
					if (rnd.y > 0.5) {
						info.glow = cap * (0.3 + 0.2 * sin(anim_time * 0.5 + rnd.x * 6.28));
					}
				}
			}
		}
	}

	// Simplified moss pattern (skip expensive root calculation most of the time)
	float moss = value_noise_simple(scaled_pos * 2.0);
	moss = smoothstep(0.35, 0.65, moss);

	// Combine: mushrooms on top, moss below
	if (mushroom_total > 0.1) {
		info.coverage = mushroom_total;
		info.is_mushroom = 1.0;
		info.is_root = 0.0;
	} else {
		info.coverage = moss * 0.5;
		info.is_mushroom = 0.0;
		info.is_root = 0.0;
		info.height = 0.1;
	}

	return info;
}

// Enhanced grass detail that returns full info for advanced coloring
GrassInfo get_grass_detail_full(vec2 xz_pos, float flatness, int biome_idx, float anim_time) {
	GrassInfo result;
	result.coverage = 0.0;
	result.height = 0.0;
	result.shadow = 0.0;
	result.wind_bend = 0.0;

	// Only show grass on flat terrain
	float slope_factor = smoothstep(0.80, 0.95, flatness);
	if (slope_factor < 0.01) return result;

	// Grass intensity varies by biome
	float biome_grass_intensity = 0.0;
	if (biome_idx == 0) biome_grass_intensity = 1.0;
	else if (biome_idx == 1) biome_grass_intensity = 0.3;
	else if (biome_idx == 2) biome_grass_intensity = 0.5;
	else if (biome_idx == 3) biome_grass_intensity = 0.0;
	else if (biome_idx == 4) biome_grass_intensity = 0.0;
	else if (biome_idx == 5) biome_grass_intensity = 0.4;
	else if (biome_idx == 6) biome_grass_intensity = 0.0;

	if (biome_grass_intensity < 0.01) return result;

	// Get full grass info
	result = get_grass_pattern(xz_pos, anim_time);
	result.coverage *= slope_factor * biome_grass_intensity;

	return result;
}

// ============================================================================
// VERTEX AND FRAGMENT SHADERS
// ============================================================================

void vertex() {
	world_pos = (MODEL_MATRIX * vec4(VERTEX, 1.0)).xyz;
	// Transform normal to world space using inverse transpose for correct orientation
	world_normal = normalize(mat3(MODEL_MATRIX) * NORMAL);

	// Snow height displacement - only on flat surfaces
	// Note: Footprints only affect color, not vertex height (terrain mesh too sparse for small details)
	if (snow_coverage > 0.01) {
		float flatness = world_normal.y;  // 1.0 = flat, 0.0 = vertical
		float snow_factor = snow_coverage * smoothstep(0.5, 0.9, flatness);

		// Add noise for natural snow surface variation
		float snow_noise = simple_rand(floor(world_pos.xz * 2.0)) * 0.3 + 0.7;

		// Calculate final snow height (no footprint displacement - handled in fragment shader)
		float displacement = snow_height * snow_factor * snow_noise;

		// Displace vertex upward along normal
		VERTEX += NORMAL * displacement;
	}
}

// Biome blend info structure
struct BiomeBlendInfo {
	int primary_biome;
	int secondary_biome;
	float blend_weight;
	bool valid;
};

// Sample biome blend info from dynamic texture (follows player, generated by GDScript)
BiomeBlendInfo sample_biome_blend_from_texture(vec2 xz_pos) {
	BiomeBlendInfo info;
	info.valid = false;
	info.primary_biome = 0;
	info.secondary_biome = 0;
	info.blend_weight = 0.0;

	// Calculate UV coordinates relative to texture center
	vec2 offset = xz_pos - biome_texture_center;
	vec2 uv = (offset / biome_texture_size) + 0.5;  // 0-1 range, centered

	// Clamp to texture bounds - outside the texture, fall back to procedural
	if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
		return info;  // Signal to use fallback
	}

	// Sample texture - R=primary biome, G=secondary biome, B=blend weight
	vec3 tex_data = texture(biome_texture, uv).rgb;
	info.primary_biome = int(tex_data.r * 7.0 + 0.5);
	info.secondary_biome = int(tex_data.g * 7.0 + 0.5);
	info.blend_weight = tex_data.b;
	info.valid = true;

	return info;
}

// Legacy function for compatibility
int sample_biome_from_texture(vec2 xz_pos) {
	BiomeBlendInfo info = sample_biome_blend_from_texture(xz_pos);
	if (!info.valid) return -1;
	return info.primary_biome;
}

void fragment() {
	vec2 xz_pos = world_pos.xz;

	// === LOD CALCULATION ===
	// Calculate distance from camera for LOD decisions
	float cam_distance = length(world_pos - camera_position);

	// LOD levels: 0 = near (full detail), 1 = mid (reduced), 2 = far (minimal)
	int lod_level = 0;
	if (cam_distance > LOD_FAR_DISTANCE) {
		lod_level = 2;
	} else if (cam_distance > LOD_MID_DISTANCE) {
		lod_level = 1;
	}

	// Try to get biome blend info from dynamic texture (perfect alignment with minimap)
	BiomeBlendInfo blend_info = sample_biome_blend_from_texture(xz_pos);

	vec3 grass_color;
	vec3 rock_color;
	int current_biome = 0;  // Track current biome for grass detail

	if (blend_info.valid) {
		current_biome = blend_info.primary_biome;

		// Get colors for both biomes
		vec3 primary_grass = get_biome_grass_color(blend_info.primary_biome);
		vec3 primary_rock = get_biome_rock_color(blend_info.primary_biome);

		// LOD: Skip biome blending at far distance
		if (lod_level < 2 && blend_info.blend_weight > 0.001) {
			vec3 secondary_grass = get_biome_grass_color(blend_info.secondary_biome);
			vec3 secondary_rock = get_biome_rock_color(blend_info.secondary_biome);

			// Blend between primary and secondary based on weight
			grass_color = mix(primary_grass, secondary_grass, blend_info.blend_weight);
			rock_color = mix(primary_rock, secondary_rock, blend_info.blend_weight);

			// Use secondary biome for grass detail if blend weight is high enough
			if (blend_info.blend_weight > 0.5) {
				current_biome = blend_info.secondary_biome;
			}
		} else {
			grass_color = primary_grass;
			rock_color = primary_rock;
		}
	} else {
		// Fall back to procedural if outside texture bounds
		current_biome = get_biome_index(xz_pos);
		grass_color = get_biome_grass_color(current_biome);
		rock_color = get_biome_rock_color(current_biome);
	}

	// Calculate slope based on how vertical the surface is (in world space)
	float flatness = world_normal.y;  // 1.0 = flat, 0.0 = vertical

	// Blend between grass and rock based on slope
	float rock_blend = 1.0 - smoothstep(0.70, 0.85, flatness);
	vec3 base_color = mix(grass_color, rock_color, rock_blend);

	// === LOD-BASED NOISE ===
	vec3 color;
	if (lod_level == 2) {
		// FAR LOD: Skip noise entirely, just use base color with simple variation
		float simple_noise = simple_rand(floor(xz_pos * 0.1)) * 0.15 - 0.075;
		color = base_color * (1.0 + simple_noise);
	} else if (lod_level == 1) {
		// MID LOD: Use single octave noise only
		float noise_val = value_noise_simple(world_pos.xz * 0.6);
		float combined = (noise_val - 0.5) * 1.5;
		color = base_color * (1.0 + combined * 0.3);
	} else {
		// NEAR LOD: Full multi-octave noise
		float noise_xz = multi_octave_noise(world_pos.xz * 0.3);
		float noise_xy = multi_octave_noise(world_pos.xy * 0.3);
		float noise_yz = multi_octave_noise(world_pos.yz * 0.3);

		// Blend noise based on surface orientation
		vec3 blend_weights = abs(world_normal);
		blend_weights = blend_weights / (blend_weights.x + blend_weights.y + blend_weights.z);

		float noise_val = noise_xz * blend_weights.y +  // Horizontal surfaces
		                  noise_xy * blend_weights.z +  // North/South facing
		                  noise_yz * blend_weights.x;   // East/West facing

		// Convert to -1 to 1 range for color variation
		float combined = (noise_val - 0.5) * 2.0;

		// Apply variation to base color
		color = base_color * (1.0 + combined * 0.4);
	}

	// Apply shader-based ground detail on flat terrain
	// LOD: Only render grass/mushroom detail when close enough
	if (enable_grass_detail && lod_level == 0) {
		// Dark forest biome (index 1) gets special mushroom/root pattern
		if (current_biome == 1 && flatness > 0.8) {
			// === DARK FOREST FLOOR - MUSHROOMS AND ROOTS ===
			ForestFloorInfo forest_info = get_forest_floor_pattern(xz_pos, time);

			if (forest_info.coverage > 0.01) {
				vec3 floor_color = grass_color;  // Base is dark teal-green

				if (forest_info.is_mushroom > 0.5) {
					// === MUSHROOM COLORING ===
					vec3 cap_edge = grass_color * 0.7;
					vec3 cap_center = grass_color * 1.4;
					cap_center = mix(cap_center, cap_center * vec3(1.2, 1.1, 0.9), 0.3);

					floor_color = mix(cap_edge, cap_center, forest_info.height);

					// Specular highlight at mushroom top
					if (forest_info.height > 0.7) {
						float spec = (forest_info.height - 0.7) * 3.0;
						floor_color = mix(floor_color, vec3(0.8, 0.9, 0.7), spec * 0.2);
					}

					// Bioluminescent glow
					if (forest_info.glow > 0.01) {
						vec3 glow_color = vec3(0.2, 0.9, 0.5);
						floor_color = mix(floor_color, glow_color, forest_info.glow * 0.6);
					}
				} else if (forest_info.is_root > 0.5) {
					// === ROOT COLORING ===
					vec3 root_color = grass_color * 0.5;
					root_color = mix(root_color, root_color * vec3(1.1, 0.9, 0.8), 0.4);
					floor_color = root_color;
				} else {
					// === MOSS COLORING ===
					vec3 moss_color = grass_color * 0.8;
					moss_color = mix(moss_color, moss_color * vec3(0.9, 1.1, 0.85), 0.3);
					floor_color = moss_color;
				}

				// Blend with base terrain
				float blend_strength = smoothstep(0.0, 0.5, forest_info.coverage);
				color = mix(color, floor_color, blend_strength);
			}
		} else {
			// === OTHER BIOMES - GRASS BLADES ===
			GrassInfo grass_info = get_grass_detail_full(xz_pos, flatness, current_biome, time);

			if (grass_info.coverage > 0.01) {
				// === GRASS BLADE COLORING ===
				vec3 blade_base_color = grass_color * 0.6;
				vec3 blade_tip_color = grass_color * 1.2;
				blade_tip_color = mix(blade_tip_color, blade_tip_color * vec3(1.05, 1.1, 0.85), 0.4);

				float height_factor = grass_info.height;
				vec3 blade_color = mix(blade_base_color, blade_tip_color, height_factor);

				// Inter-blade shadows
				float shadow_factor = grass_info.shadow * grass_info.coverage;
				blade_color *= (1.0 - shadow_factor * 0.4);

				// Subsurface scattering
				float sss_strength = height_factor * grass_info.coverage * 0.25;
				vec3 sss_color = grass_color * vec3(1.1, 1.2, 0.9) * 1.3;
				blade_color = mix(blade_color, sss_color, sss_strength * grass_info.wind_bend);

				// Wind highlight
				float wind_highlight = grass_info.wind_bend * grass_info.coverage * 0.15;
				blade_color *= (1.0 + wind_highlight);

				// Specular-like highlight on blade tips
				if (height_factor > 0.75 && grass_info.coverage > 0.5) {
					float tip_spec = (height_factor - 0.75) * 4.0 * grass_info.coverage;
					blade_color = mix(blade_color, vec3(1.0), tip_spec * 0.08);
				}

				// Blend with base terrain
				float blend_strength = smoothstep(0.0, 0.6, grass_info.coverage);
				color = mix(color, blade_color, blend_strength);

				// Edge darkening
				float edge_factor = smoothstep(0.0, 0.2, grass_info.coverage);
				color *= mix(0.92, 1.0, edge_factor);
			}
		}
	}

	// Simple directional lighting
	vec3 light_dir = normalize(vec3(0.5, 1.0, 0.3));
	float ndotl = max(dot(world_normal, light_dir), 0.0);
	float ambient = 0.6;
	float lighting = ambient + (1.0 - ambient) * ndotl;

	// === SNOW COVERAGE ===
	// Blend terrain towards white based on snow coverage
	if (snow_coverage > 0.01) {
		// Snow color - slightly blue-tinted white for realism
		vec3 snow_color = vec3(0.95, 0.97, 1.0);

		// Snow accumulates more on flat surfaces
		float snow_factor = snow_coverage * smoothstep(0.5, 0.9, flatness);

		// Sample footprint texture
		vec2 footprint_offset = xz_pos - footprint_texture_center;
		vec2 footprint_uv = (footprint_offset / footprint_texture_size) + 0.5;
		float footprint_value = 1.0;
		if (footprint_uv.x >= 0.0 && footprint_uv.x <= 1.0 && footprint_uv.y >= 0.0 && footprint_uv.y <= 1.0) {
			footprint_value = texture(footprint_texture, footprint_uv).r;
		}

		// Add noise for patchy snow coverage
		float snow_noise = value_noise_simple(xz_pos * 0.5);
		snow_noise = smoothstep(0.3, 0.7, snow_noise);

		// Snow blends in based on coverage and noise
		float final_snow = snow_factor * (0.7 + snow_noise * 0.3);

		// Blend base color towards snow
		color = mix(color, snow_color, final_snow);

		// === FOOTPRINT RENDERING ===
		if (footprint_value < 0.95) {
			// Footprint detected - show compressed snow/ground
			// The lower the footprint_value, the deeper the footprint

			// Darker compressed snow color in footprint
			vec3 compressed_snow = snow_color * 0.7;  // Darker snow in footprint
			vec3 ground_showing = color * 0.5;  // Ground visible in deep parts

			// Mix between compressed snow and ground based on depth
			float depth = 1.0 - footprint_value;  // 0 = shallow, 1 = deep
			vec3 footprint_color = mix(compressed_snow, ground_showing, depth * 0.6);

			// Add shadow on the edges of footprint (rim shadow)
			float rim = smoothstep(0.3, 0.7, footprint_value) * (1.0 - smoothstep(0.7, 0.95, footprint_value));
			footprint_color *= (1.0 - rim * 0.2);  // Darken rim

			// Apply footprint
			float footprint_blend = smoothstep(0.95, 0.5, footprint_value);  // Stronger blend for deeper prints
			color = mix(color, footprint_color, footprint_blend * snow_factor);
		}
	}

	// Debug mode: directly show the grass color from texture (for troubleshooting)
	if (debug_biome_colors) {
		// Show grass color directly - reveals if biome texture is working
		ALBEDO = grass_color;
		ROUGHNESS = 0.9;
		METALLIC = 0.0;
	} else {
		ALBEDO = color * lighting;
		// Rocky areas are slightly rougher - snow is smoother
		float base_roughness = mix(0.85, 0.95, rock_blend);
		ROUGHNESS = mix(base_roughness, 0.7, snow_coverage * smoothstep(0.5, 0.9, flatness));
		METALLIC = 0.0;
	}
}
